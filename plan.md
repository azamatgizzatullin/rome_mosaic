# Детализированный план работы над генератором мозаики

## Цель
Создать алгоритм укладки тессер, который не просто заполняет цветовые зоны, а делает это осмысленно, следуя канонам римской мозаики:
1.  **Точное следование контурам:** Тессеры должны обрисовывать границы объектов и цветовых переходов.
2.  **Использование конкретных форм:** Только прямоугольники, квадраты, треугольники и трапеции. Никаких сложных многоугольников.
3.  **Геометрическая корректность:** Избегать слишком тонких, вытянутых, остроугольных или искаженных тессер.
4.  **Плотная укладка:** Минимизация швов между тессерами.
5.  **Отсутствие наложений:** Тессеры не должны перекрываться.
6.  **Адаптивный размер:** Возможность использовать тессеры разного размера для контуров и для заполнения фона.

## Используемые технологии и библиотеки
*   **OpenCV:** Чтение/запись изображений, базовые операции с контурами, отрисовка.
*   **Shapely:** Ключевая библиотека для сложных геометрических операций с полигонами.
*   **NumPy:** Работа с массивами координат, математические вычисления.

## Основной скрипт
`scripts/mosaic_composer_v8.py`

## Этапы работ

### Этап 0: Подготовка и получение полигонов цветовых зон (ЗАВЕРШЕН)

*   **Статус:** ЗАВЕРШЕН
*   **Задача:** Извлечь из исходного изображения (после квантования) полигоны, представляющие уникальные цветовые зоны, с корректной обработкой внутренних "дыр".
*   **Реализация:** Функция `get_color_zone_polygons(image_path, min_area_threshold)` в `scripts/mosaic_composer_v8.py`.
    *   Загрузка изображения.
    *   Нахождение уникальных цветов.
    *   Для каждого цвета:
        *   Создание маски.
        *   Поиск контуров (`cv2.findContours` с `cv2.RETR_TREE`).
        *   Преобразование OpenCV контуров в `Shapely Polygon` с использованием `Polygon(shell=..., holes=...)`.
        *   Валидация полигонов с помощью `shapely.validation.make_valid`.
        *   Фильтрация по минимальной площади.
    *   **Результат:** Словарь `{color_tuple: [list_of_Shapely_Polygons]}`.

### Этап 1: Укладка тессер вдоль контуров (Opus Vermiculatum)

*   **Статус:** В РАБОТЕ
*   **Задача:** Создать 1-3 ряда тессер, точно следующих внешним и внутренним контурам каждой цветовой зоны.
*   **Функция:** `create_contour_tesserae_bands(color_zone_polygon, num_bands, tessera_avg_short_side, tessera_avg_long_side_factor, main_color_rgb)`.
*   **Параметры:**
    *   `color_zone_polygon`: `Shapely Polygon` текущей цветовой зоны.
    *   `num_bands`: Количество рядов тессер (например, 1, 2 или 3).
    *   `tessera_avg_short_side`: Ширина тессеры (перпендикулярно контуру).
    *   `tessera_avg_long_side_factor`: Коэффициент для определения длины тессеры (вдоль контура), например, 1.5-2.5 от `tessera_avg_short_side`.
    *   `main_color_rgb`: Цвет тессер (для последующей отрисовки).
*   **Алгоритм (итерационная разработка):**
    1.  **Обработка внешнего контура и дыр:** Алгоритм должен итерировать по `polygon.exterior` и `polygon.interiors`.
    2.  **Создание параллельных полос:** Для каждой полосы (ряда тессер) использовать `contour.parallel_offset()` или `polygon.buffer()` для получения внутренней параллельной линии/области.
    3.  **Сегментация контура/полосы:** Разбить контур (или его параллельную версию) на отрезки (сегменты).
    4.  **Генерация тессер для сегмента:**
        *   Для каждого сегмента определить его направление (тангенс) и нормаль.
        *   "Нарезать" из полосы прямоугольные тессеры, ориентированные вдоль тангенса.
        *   Длина тессеры: `tessera_avg_short_side * tessera_avg_long_side_factor`.
        *   Ширина тессеры: `tessera_avg_short_side`.
    5.  **Обработка углов и изгибов (сложная часть, будет дорабатываться):**
        *   В местах соединения сегментов (углы) и на изгибах формы могут отличаться от простых прямоугольников.
        *   Рассмотреть возможность использования трапеций или треугольников для лучшего прилегания.
        *   Возможно, первоначально укладывать прямоугольники, а затем заполнять зазоры.
    6.  **Валидация и коррекция тессер:**
        *   Каждая созданная тессера должна быть `Shapely Polygon`.
        *   Тессера должна находиться внутри исходного `color_zone_polygon` (или быть его частью).
        *   Избегать пересечений с уже уложенными тессерами (вычитать их площадь из доступной).
        *   Соответствовать критериям формы (не слишком узкие/мелкие).
    7.  **Хранение тессер:** Собирать все сгенерированные тессеры (полигоны) в список, возможно, с указанием их цвета.
*   **Результат функции:** Список `Shapely Polygon` (тессер) для контурных полос и обновленный `Shapely Polygon` (или `MultiPolygon`) для оставшейся внутренней области цветовой зоны (исходная зона минус площадь контурных тессер).

### Этап 2: Заполнение внутренних областей (Opus Tessellatum)

*   **Статус:** ПЛАНИРУЕТСЯ
*   **Задача:** Заполнить оставшуюся часть цветовой зоны после укладки контурных тессер.
*   **Функция:** `fill_interior_region(remaining_polygon, tessera_avg_width, tessera_avg_height, main_color_rgb)`.
*   **Алгоритм (варианты для исследования):**
    *   **Определение доминирующего направления:** Использовать `minimum_rotated_rectangle` или глобальное направление.
    *   **Стратегия 1: Регулярная сетка с обрезкой и адаптацией.**
        *   Создать регулярную сетку прямоугольников-кандидатов.
        *   Для каждого кандидата вычислить пересечение с `remaining_polygon`.
        *   Попытаться аппроксимировать/разбить полученное пересечение до разрешенных форм (прямоугольник, квадрат, трапеция, треугольник).
    *   **Стратегия 2: Последовательное "жадное" заполнение.**
        *   Начать с границы `remaining_polygon`.
        *   Размещать максимально большие допустимые фигуры.
        *   Обновлять `remaining_polygon` после каждой уложенной тессеры.
        *   Мелкие остатки заполнять треугольниками/трапециями.
    *   **Валидация и избегание наложений.**
*   **Результат функции:** Список `Shapely Polygon` (тессер) для внутренней области.

### Этап 3: Постобработка, визуализация и сборка

*   **Статус:** ПЛАНИРУЕТСЯ (частично будет реализовываться параллельно для отладки)
*   **Задачи:**
    1.  **Сборка всех тессер:** Объединить тессеры из Этапа 1 и Этапа 2.
    2.  **Финальная валидация и очистка (refine_and_validate_tesserae):**
        *   Проверка форм всех тессер.
        *   Удаление/исправление геометрически некорректных тессер.
        *   Попытки минимизации швов (опционально, сложно).
    3.  **Отрисовка и сохранение результата:**
        *   Создать холст.
        *   Нарисовать каждую тессеру ее цветом (`cv2.drawContours` с `cv2.FILLED`).
        *   Нарисовать обводку для каждой тессеры (например, черную).
        *   Сохранить финальное изображение.
    4.  **Интеграция в `main.py` (если потребуется отдельный вызов, или `mosaic_composer_v8.py` станет основным скриптом для этого шага).**

## Параметры для настройки пользователем (через `argparse`)

*   `--input_image`: Путь к исходному изображению.
*   `--output_dir`: Директория для сохранения результатов.
*   `--min_contour_area`: Минимальная площадь цветовой зоны для обработки.
*   `--num_contour_bands`: Количество рядов тессер вдоль контуров (для Этапа 1).
*   `--contour_tessera_short_side`: Ширина контурных тессер.
*   `--contour_tessera_long_factor`: Коэффициент длины для контурных тессер.
*   `--interior_tessera_width`: Ширина тессер для внутреннего заполнения (для Этапа 2).
*   `--interior_tessera_height`: Высота тессер для внутреннего заполнения (для Этапа 2).
*   `--min_tessera_area`: Минимально допустимая площадь отдельной тессеры.
*   `--tessera_outline_thickness`: Толщина обводки тессер (0 для отсутствия).

## Критические моменты и вызовы

*   Алгоритмы приведения произвольных полигонов к разрешенным формам.
*   Обработка углов и кривых при укладке контурных тессер.
*   Эффективное обнаружение и предотвращение наложений тессер.
*   Баланс между плотностью укладки, правильностью форм и производительностью. 